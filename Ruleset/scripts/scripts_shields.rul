
extended:
  tags:
    RuleArmor:
      # *** Tags for energy shield on armor ***
      ARMOR_ENERGY_SHIELD_HP_PER_TURN: int
      ARMOR_ENERGY_SHIELD_DECAY: int

      # *** Tags for shield penetrating on weapon ***
    RuleItem:
      ITEM_ENERGY_SHIELD_PENETRATION_PERCENT: int
      ITEM_ENERGY_SHIELD_PENETRATION_FLAT_AMOUNT: int
      ITEM_ENERGY_SHIELD_REDUCTION_PERCENT: int
      ITEM_ENERGY_SHIELD_REDUCTION_FLAT_AMOUNT: int
      ITEM_ENERGY_SHIELD_IGNORE_TYPE_BYPASS: int  # overrides damage type bypassing if true
      ITEM_EFFECT_DURATION: int # effect duration

    BattleUnit:
      # *** Tags for handling energy shields on units ***
      UNIT_ENERGY_SHIELD_HP: int
      UNIT_ENERGY_SHIELD_DECAY: int
      UNIT_BONUS_ENERGY_SHIELD_HP_PER_TURN: int # shield regen from soldierbonus
      UNIT_BONUS_ENERGY_SHIELD_DECAY: int       # shield decay from soldierbonus
      UNIT_SHIELD_ENDTURN: int # store duration for shield from item/ability

  scripts:
    hitUnit:
      # *** Defense layer: does the unit have an energy shield? ***
      - update: 40k_hU_personal_shields
        offset: 12
        code: |
          var int shieldHP;
          var int shieldHPAfter;
          var int frame;
          var int shieldFlatPenetration;
          var int shieldPercentagePenetration;
          var int shieldFlatReduction;
          var int shieldPercentageReduction;
          var ptre BattleItem attackingAmmo;
          var int temp;

          unit.getTag temp Tag.UNIT_MARKED_FOR_EXECUTION;
          if eq temp 1;
            # debug_log "Commissar Execution Mode Scripts; 40k_hU_personal_shields, offset 12: Target marked for execution. Aborting. UNIT_MARKED_FOR_EXECUTION:" temp;
            return power part side;
          end;

          unit.getTag shieldHP Tag.UNIT_ENERGY_SHIELD_HP;

          if eq shieldHP 0;
            return power part side;
          else or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10;
            damaging_item.getTag temp Tag.ITEM_ENERGY_SHIELD_IGNORE_TYPE_BYPASS; # check to see whether the weapon or ammo ignores the damage type bypass
            attackingAmmo.getTag frame Tag.ITEM_ENERGY_SHIELD_IGNORE_TYPE_BYPASS;
            add temp frame;
            if eq temp 0; # if we don't ignore the damage typing bypass, bypass
              return power part side;
            end;
          end;

          # check if our weapon or ammo ignores shields
          damaging_item.getAmmoItem attackingAmmo;
          damaging_item.getTag shieldPercentagePenetration Tag.ITEM_ENERGY_SHIELD_PENETRATION_PERCENT;
          attackingAmmo.getTag temp Tag.ITEM_ENERGY_SHIELD_PENETRATION_PERCENT;
          # total ammo and weapon shield penetration
          add shieldPercentagePenetration temp;
          # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Total shieldPercentagePenetration:" shieldPercentagePenetration;

          # if we straight up ignore shields, do so and abort
          if ge shieldPercentagePenetration 100;
            # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Weapon/ammo ignores shields. Aborting. shieldPercentagePenetration:" shieldPercentagePenetration;
            return power part side;
          end;

          unit.getTag shieldHP Tag.UNIT_ENERGY_SHIELD_HP;
          # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Base shield initial value (shieldHP): " shieldHP;

          # calculate flat shield penetration
          damaging_item.getTag shieldFlatPenetration Tag.ITEM_ENERGY_SHIELD_PENETRATION_FLAT_AMOUNT;
          attackingAmmo.getTag temp Tag.ITEM_ENERGY_SHIELD_PENETRATION_FLAT_AMOUNT;
          # total ammo and weapon shield penetration
          add shieldFlatPenetration temp;
          # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Total shieldFlatPenetration:" shieldFlatPenetration;

          # if we straight up ignore shields, do so and abort
          if ge shieldFlatPenetration shieldHP;
            # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Weapon/ammo ignores shields. Aborting. shieldFlatPenetration:" shieldFlatPenetration;
            return power part side;
          end;

          # calculate flat shield reduction
          damaging_item.getTag shieldFlatReduction Tag.ITEM_ENERGY_SHIELD_REDUCTION_FLAT_AMOUNT;
          attackingAmmo.getTag temp Tag.ITEM_ENERGY_SHIELD_REDUCTION_FLAT_AMOUNT;
          # total ammo and weapon shield flat reduction
          add shieldFlatReduction temp;
          # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Total shieldFlatReduction:" shieldFlatReduction;

          # calculate percentage shield reduction
          damaging_item.getTag shieldPercentageReduction Tag.ITEM_ENERGY_SHIELD_REDUCTION_PERCENT;
          attackingAmmo.getTag temp Tag.ITEM_ENERGY_SHIELD_REDUCTION_PERCENT;
          # total ammo and weapon shield flat reduction
          add shieldPercentageReduction temp;
          # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Total shieldPercentageReduction:" shieldPercentageReduction;

          # temp value is equal to our effective shield hp that can be adjusted by penetration
          set temp shieldHP;
          # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Effective shield initial value (temp): " temp;
          # apply shield flat penetration
          if ge shieldFlatPenetration 0;
            sub temp shieldFlatPenetration; # reduce effective shielding by this amount
            limit_lower temp 0;
          end;

          # apply shield percentage penetration
          if ge shieldPercentagePenetration 0;
            sub shieldPercentagePenetration 100; # invert shield penetration
            mul shieldPercentagePenetration -1;
            muldiv temp shieldPercentagePenetration 100; # reduce effective shielding by this amount
          end;

          # reduce the actual ShieldHP and effective shield HP by shieldPercentageReduction
          if ge shieldPercentageReduction 0;
            sub shieldPercentageReduction 100; # invert shield reduction
            mul shieldPercentageReduction -1;
            muldiv shieldHP shieldPercentageReduction 100; # reduce effective shielding by this amount
            muldiv temp shieldPercentageReduction 100; # reduce effective shielding by this amount
            # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Shield values after shieldPercentageReduction (temp): " temp;
            # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Shield values after shieldPercentageReduction (shieldHP): " shieldHP;
          end;

          # reduce the actual ShieldHP and effective shield HP by shieldFlatReduction
          sub shieldHP shieldFlatReduction;
          sub temp shieldFlatReduction;
          limit_lower shieldHP 0;
          limit_lower temp 0;
          # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Shield values after shieldFlatReduction (temp): " temp;
          # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Shield values after shieldFlatReduction (shieldHP): " shieldHP;

          set shieldHPAfter shieldHP;
          sub shieldHPAfter power;
          # subtract from power the lower of temp (adjusted shield HP) or real shield HP.
          if lt temp shieldHP;
            sub power temp;
            # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Effective Shield value lower than Base Shield (temp): " temp;
            # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Effective Shield value lower than Base Shield (shieldHP): " shieldHP;
          else;
            sub power shieldHP;
            # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Effective Shield value higher than Base Shield (temp): " temp;
            # debug_log "40k_hU_personal_shields; damageUnit, offset 12: Effective Shield value higher than Base Shield (shieldHP): " shieldHP;
          end;
          limit_lower shieldHPAfter 0;
          limit_lower power 0;
          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP shieldHPAfter;

          if and gt shieldHPAfter 0 eq power 0;

            battle_game.getAnimFrame frame;
            unit.setTag Tag.UNIT_RECOLOR_START_FRAME frame;
            unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 3;
            unit.setTag Tag.UNIT_RECOLOR_COLOR COLOR_X1_BLUE1;

          end;

          return power part side;

    newTurnUnit:
      #*** Handles decay of energy shields and shield HP added by armors ***
      - override: 40k_nTU_personal_shields
        offset: 13
        code: |
          var ptr RuleArmor armorRuleset;
          var int shieldHP;
          var int shieldDecay;
          var int shieldAdded;
          var int temp;
          var int endTurn;

          # Make sure this doesn't run an extra third time if there's a neutral side
          if eq side 2;
            return;
          end;

          # Check armor/unit first for decay parameter
          unit.getRuleArmor armorRuleset;
          armorRuleset.getTag shieldDecay Tag.ARMOR_ENERGY_SHIELD_DECAY;
          unit.getTag temp Tag.UNIT_BONUS_ENERGY_SHIELD_DECAY;
          if and gt shieldDecay 0 gt temp 0; # if unit has both sources of shield decay, average them
            add shieldDecay temp;
            div shieldDecay 2;
          else;
            limit_lower shieldDecay temp; # if unit only has one source, use that
          end;

          # If they don't have either, use decay set by item
          if eq shieldDecay 0;
            unit.getTag shieldDecay Tag.UNIT_ENERGY_SHIELD_DECAY;
          end;

          # Next comes decay set by an item
          if eq shieldDecay 0;
            unit.getTag shieldDecay Tag.UNIT_ENERGY_SHIELD_DECAY;
          end;

          set temp shieldDecay; # use temp var to keep calcuated shieldDecay intact for later
          # Apply the decay, treating it like the percent lost per turn
          unit.getTag shieldHP Tag.UNIT_ENERGY_SHIELD_HP;
          sub temp 100;
          mul temp -1;
          muldiv shieldHP temp 100;
          # Now add the per-turn amount, to be balanced by decay parameter
          armorRuleset.getTag shieldAdded Tag.ARMOR_ENERGY_SHIELD_HP_PER_TURN;
          unit.getTag temp Tag.UNIT_BONUS_ENERGY_SHIELD_HP_PER_TURN;
          add shieldAdded temp; # combine shield gain from armor and soldierBonus
          add shieldHP shieldAdded;

          # Only run this at the start of the units turn
          unit.getFaction temp;
          if eq side temp;
            # Handle removing temporary shields that don't decay
            unit.getTag endTurn Tag.UNIT_SHIELD_ENDTURN;
            #debug_log "Shield newTurn Ping (turn/endTurn/shields) " turn endTurn shieldHP;
            if eq turn 1;
              set endTurn 0; # reset at the start for multi-stage missions
            end;
            if and neq endTurn 0 ge turn endTurn; # if shield has an expiry turn and it has expired
              if gt shieldAdded 0;
                if neq 0 shieldDecay;
                  muldiv shieldAdded 100 shieldDecay;
                end;
                limit_upper shieldHP shieldAdded; # if unit has inbuilt shield, limit their remaining shield to whatever max it provides
              else;
                set shieldHP 0; # if they don't, remove any remaining shield
              end;
              unit.setTag Tag.UNIT_SHIELD_ENDTURN 0;
            end;
          end;

          if eq shieldHP 0;
            unit.setTag Tag.UNIT_ENERGY_SHIELD_DECAY 0;
          end;

          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP shieldHP;

          return;

    damageUnit:
      #*** Spells that add to energy shields - modified from 40k to account for turn-limited shields that don't decay***
      - override: 40k_dU_spell_personal_shields
        offset: 11
        code: |
          var ptr RuleItem weaponRuleset;
          var int shieldAdded;
          var int scalingFactor;
          var int linearAddition;
          var int diminishingAddition;
          var int shieldHP;
          var int shieldDecay;
          var int currentDecay;
          var int currTurn;
          var int endTurn;

          damaging_item.getRuleItem weaponRuleset;
          weaponRuleset.getTag shieldAdded Tag.ITEM_ADDS_ENERGY_SHIELD_FROM_POWER;

          if eq shieldAdded 0;
            weapon_item.getRuleItem weaponRuleset;
            weaponRuleset.getTag shieldAdded Tag.ITEM_ADDS_ENERGY_SHIELD_FROM_POWER;
            if eq shieldAdded 0;
              return;
            end;
          end;

          set scalingFactor 50; # Percent factor for diminishing returns beyond the power of the item

          set linearAddition currPower;
          muldiv linearAddition shieldAdded 100;
          set diminishingAddition linearAddition;

          unit.getTag shieldHP Tag.UNIT_ENERGY_SHIELD_HP;
          sub linearAddition shieldHP;

          if gt linearAddition 0;
            set diminishingAddition shieldHP;
          else;
            mul linearAddition -1;
            muldiv linearAddition 100 diminishingAddition;
            sub scalingFactor linearAddition;
            limit_lower scalingFactor 0;
            set linearAddition 0;
          end;

          muldiv diminishingAddition scalingFactor 100;
          add linearAddition diminishingAddition;
          add shieldHP linearAddition;
          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP shieldHP;
          battle_game.flashMessage "STR_SCRIPT_SHIELD_ACTIVE" shieldHP;

          weaponRuleset.getTag shieldDecay Tag.ITEM_SETS_ENERGY_SHIELD_DECAY;
          unit.getTag currentDecay Tag.UNIT_ENERGY_SHIELD_DECAY;
          if gt shieldDecay currentDecay;
            unit.setTag Tag.UNIT_ENERGY_SHIELD_DECAY shieldDecay;
          end;

          weaponRuleset.getTag endTurn Tag.ITEM_EFFECT_DURATION;
          if gt endTurn 0;
            battle_game.getTurn currTurn;
            add endTurn currTurn;
            unit.setTag Tag.UNIT_SHIELD_ENDTURN endTurn;
          end;

          #debug_log "PsyShield (Shield/Power/Decay/endTurn/currTurn) " shieldHP currPower shieldDecay endTurn currTurn;

          return;